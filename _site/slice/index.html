<!DOCTYPE html>
<html lang="en">
	<head>
	<meta charset="utf-8">
	<link rel="stylesheet" href="/bootstrap.min.css">
	<link rel="stylesheet" href="/gen.css">
	<link rel="icon" type="image/png" href="/gopher.png">
	<title>
		gen &middot; type-driven code generation for Go
		
			&middot; slice 
		
	</title>

	</head>
	<body>

		<table>
			<tbody>
				<tr>
					<td>
						<div class="nav"><h4><a href="/#">home</a></h4>

<p><a href="/#quick-start">Quick start</a></p>

<p><a href="/#typewriters">TypeWriters</a></p>

<p><a href="/#faq">FAQ</a></p>

<h4><a href="/slice">slice</a></h4>

<p><a href="/slice/#aggregatet">Aggregate[T]</a></p>

<p><a href="/slice/#all">All</a></p>

<p><a href="/slice/#any">Any</a></p>

<p><a href="/slice/#average">Average</a></p>

<p><a href="/slice/#averaget">Average[T]</a></p>

<p><a href="/slice/#count">Count</a></p>

<p><a href="/slice/#distinct">Distinct</a></p>

<p><a href="/slice/#distinctby">DistinctBy</a></p>

<p><a href="/slice/#first">First</a></p>

<p><a href="/slice/#groupbyt">GroupBy[T]</a></p>

<p><a href="/slice/#max">Max</a></p>

<p><a href="/slice/#maxt">Max[T]</a></p>

<p><a href="/slice/#maxby">MaxBy</a></p>

<p><a href="/slice/#min">Min</a></p>

<p><a href="/slice/#mint">Min[T]</a></p>

<p><a href="/slice/#minby">MinBy</a></p>

<p><a href="/slice/#select">Select</a></p>

<p><a href="/slice/#sort">Sort</a></p>

<p><a href="/slice/#sortby">SortBy</a></p>

<p><a href="/slice/#where">Where</a></p>

<h4><a href="/container">container</a></h4>
</div>
					</td>
					<td>
						<h1><a href="/">gen</a></h1>
						<h2 id="the-slice-typewriter">The <code>slice</code> typewriter</h2>

<p>The <code>slice</code> typewriter is built into <a href="../"><code>gen</code></a> by default. It generates functional convenience methods that will look familiar to users of C#’s LINQ or JavaScript’s Array. It is intended to save you some loops, using a “pass a function” pattern. It offers easier ad-hoc sorts.</p>

<h3 id="aggregatet">Aggregate[T]</h3>

<p>Iterates over a slice, operating on each element while maintaining ‘state’. Comparable to Linq’s Aggregate or underscore’s reduce.</p>

<p>Example:</p>

<pre><code>var join = func(state string, value Employee) string {
    if state != "" {
        state += ", "
    }
    return state + value.Department
}
list := people.AggregateString(join)
// =&gt; "Sales, Marketing, Finance"
</code></pre>

<h3 id="all">All</h3>

<h3 id="any">Any</h3>

<h3 id="average">Average</h3>

<h3 id="averaget">Average[T]</h3>

<h3 id="count">Count</h3>

<h3 id="distinct">Distinct</h3>

<h3 id="distinctby">DistinctBy</h3>

<h3 id="first">First</h3>

<h3 id="groupbyt">GroupBy[T]</h3>

<h3 id="max">Max</h3>

<h3 id="maxt">Max[T]</h3>

<h3 id="maxby">MaxBy</h3>

<h3 id="min">Min</h3>

<h3 id="mint">Min[T]</h3>

<h3 id="minby">MinBy</h3>

<h3 id="select">Select</h3>

<h3 id="sort">Sort</h3>

<h3 id="sortby">SortBy</h3>

<h3 id="where">Where</h3>

<p>Returns a new slice whose elements return true for passed func. Comparable to LINQ’s <a href="http://msdn.microsoft.com/en-us/library/bb534803(v=vs.110).aspx">Where</a> and JavaScript’s <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">filter</a>.</p>

<pre><code>func (rcv ExampleSlice) Where(fn func(Example) bool) ExampleSlice
</code></pre>

<p>Example:</p>

<pre><code>shiny := func(p Product) bool {
	return p.Manufacturer == "Apple"
}
wishlist := products.Where(shiny)
</code></pre>

					</td>
				</tr>
			</tbody>
		</table><br />
	</body>
</html>
