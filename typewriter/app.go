package typewriter

import (
	"bytes"
	"fmt"
	"go/parser"
	"go/token"
	"io"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"code.google.com/p/go.tools/imports"
)

// +test foo:"Bar" baz:"qux[struct{}],thing"
type app struct {
	// All typewriter.Type found in the current directory.
	Types []Type
	// All typewriter.TypeWriters registered on init.
	TypeWriters []TypeWriter
	Directive   string
}

// NewApp parses the current directory, collecting Types and their related information.
func NewApp(directive string) (*app, error) {
	return NewAppFiltered(directive, nil)
}

// NewAppFiltered parses the current directory, collecting Types and their related information. Pass a filter to limit which files are operated on.
func NewAppFiltered(directive string, filter func(os.FileInfo) bool) (*app, error) {
	a := &app{
		Directive: directive,
	}

	typs, err := getTypes(directive, filter)
	if err != nil {
		return a, err
	}

	a.Types = typs
	a.TypeWriters = typeWriters
	return a, nil
}

// Individual TypeWriters register on init, keyed by name
var typeWriters []TypeWriter

// Register allows template packages to make themselves known to a 'parent' package, usually in the init() func.
// Comparable to the approach taken by builtin image package for registration of image types (eg image/png).
// Your program will do something like:
//	import (
//		"github.com/clipperhouse/gen/typewriter"
//		_ "github.com/clipperhouse/gen/typewriters/container"
//	)
func Register(tw TypeWriter) error {
	for _, v := range typeWriters {
		if v.Name() == tw.Name() {
			return fmt.Errorf("A TypeWriter by the name %s has already been registered", tw.Name())
		}
	}
	typeWriters = append(typeWriters, tw)
	return nil
}

// WriteAll writes the generated code for all Types and TypeWriters in the App to respective files.
func (a *app) WriteAll() error {
	// one buffer for each file, keyed by file name
	buffers := make(map[string]*bytes.Buffer)

	// write the generated code for each Type & TypeWriter into memory
	for _, t := range a.Types {
		for _, tw := range a.TypeWriters {
			var b bytes.Buffer
			n, err := write(&b, a, t, tw)

			if err != nil {
				return err
			}

			// don't generate a file if no bytes were written by WriteHeader or WriteBody
			if n == 0 {
				continue
			}

			// append _test to file name if the source type is in a _test.go file
			f := strings.ToLower(fmt.Sprintf("%s_%s%s.go", t.Name, tw.Name(), t.test))

			buffers[f] = &b
		}
	}

	// validate generated ast's before committing to files
	for f, b := range buffers {
		if _, err := parser.ParseFile(token.NewFileSet(), f, b.String(), 0); err != nil {
			// TODO: prompt to write (ignored) _file on error? parsing errors are meaningless without.
			return err
		}
	}

	// format, remove unused imports, and commit to files
	for f, b := range buffers {
		src, err := imports.Process(f, b.Bytes(), nil)

		// shouldn't be an error if the ast parsing above succeeded
		if err != nil {
			return err
		}

		if err := writeFile(f, src); err != nil {
			return err
		}
	}

	return nil
}

var twoLines = bytes.Repeat([]byte{'\n'}, 2)

func write(w *bytes.Buffer, a *app, t Type, tw TypeWriter) (n int, err error) {
	// start with byline at top, give future readers some background
	// on where the file came from
	bylineFmt := `// Generated by: %s
// TypeWriter: %s
// Directive: %s on %s`

	caller := filepath.Base(os.Args[0])
	byline := fmt.Sprintf(bylineFmt, caller, tw.Name(), a.Directive, t.String())
	w.Write([]byte(byline))
	w.Write(twoLines)

	// we only care about written bytes for WriteHeader and WriteBody
	var c countingWriter

	c = countingWriter{0, w}
	err = tw.WriteHeader(&c, t)
	n += c.n

	if err != nil {
		return n, err
	}

	w.Write(twoLines)

	// add a package declaration
	pkg := fmt.Sprintf("package %s", t.Package.Name())
	w.Write([]byte(pkg))
	w.Write(twoLines)

	if err := importsTmpl.Execute(w, tw.Imports(t)); err != nil {
		return n, err
	}

	c = countingWriter{0, w}
	err = tw.WriteBody(&c, t)
	n += c.n

	return n, err
}

func writeFile(filename string, byts []byte) error {
	w, err := os.Create(filename)

	if err != nil {
		return err
	}

	defer w.Close()

	w.Write(byts)

	// TODO: make this optional or do a proper logging/verbosity thing
	fmt.Printf("  Writing %s\n", filename)

	return nil
}

var importsTmpl = template.Must(template.New("imports").Parse(`{{if gt (len .) 0}}
import ({{range .}}
	{{.Name}} "{{.Path}}"{{end}}
)
{{end}}
`))

// a writer that knows how much writing it did
// https://groups.google.com/forum/#!topic/golang-nuts/VQLtfRGqK8Q
type countingWriter struct {
	n int
	w io.Writer
}

func (c *countingWriter) Write(p []byte) (n int, err error) {
	n, err = c.w.Write(p)
	c.n += n
	return
}
