<h1>gen</h1>

<h3>A type-driven code generation tool for Go</h3>

<p><strong>gen</strong> is an attempt to bring some generics-like functionality to Go. It uses type annotations to add &ldquo;of &lt;T&gt;&rdquo; functionality to your packages.</p>

<p>gen generates code for your types, at development time, using the command line. It is not an import; the generated source becomes part of your package and takes no external dependencies.</p>

<h2>Quick start</h2>

<p>Of course, start by installing Go, <a href="http://golang.org/doc/code.html">setting up paths</a>, etc. Then:</p>

<p><code>
go get github.com/clipperhouse/gen
</code></p>

<p>Create a new Go project, and <code>cd</code> into it. Create a <code>main.go</code> file and define a type.</p>

<p>Now, mark it up with a <code>+gen</code> annotation in an adjacent comment like so:</p>

<p><code>
// +gen slice:"Where,Count,GroupBy[string]"
type MyType struct {
    ...
}
</code></p>

<p>And at the command line, simply type:</p>

<p><code>
gen
</code></p>

<p>You should see a new file, named <code>mytype_slice.go</code>. Have a look around.</p>

<p>(The annotation syntax will look familiar to Go users, it is modeled after struct tags.)</p>

<h2>TypeWriters</h2>

<p>gen is driven by &ldquo;type writers&rdquo; &ndash; packages which are responsible for interpreting the annotated tags and turning them into generated code.</p>

<p>gen includes two built-in TypeWriters.</p>

<h3><code>slice</code></h3>

<p>The <code>slice</code> typewriter generates functional convenience methods that will look familiar to users of C#&rsquo;s LINQ or JavaScript&rsquo;s Array methods. It is intended to save you some loops, using a &ldquo;pass a function&rdquo; pattern. It offers grouping, filtering, ad-hoc sorts and projections. <a href="slice">Details and docs&hellip;</a></p>

<h3><code>container</code></h3>

<p>The <code>container</code> typewriter implements strongly-typed versions of the List and Ring containers from the Go standard library, as well as a simple Set implementation. <a href="container">Details and docs&hellip;</a></p>

<h3>Using third-party TypeWriters</h3>

<p>TypeWriters can be implemented by third-parties and used at &ldquo;gen time&rdquo;. To use a third-party typewriter, <code>cd</code> into the root of your package and type:</p>

<p><code>
gen custom
</code></p>

<p>This will create a <code>_gen.go</code> file. Have a look at it &ndash; it contains the two built-in typewriters (above) as imports.</p>

<p>You&rsquo;ll note that typewriters are imported similarly to <a href="http://golang.org/pkg/image/png/">codecs</a> in the image package, or <a href="http://golang.org/pkg/database/sql/driver/">drivers</a> in the sql package. If you know the import path of a third-party typewriter, add the import:</p>

<p><code>
. "gitplace.com/kimye/bling"
</code></p>

<p>Now, make sure to type:</p>

<p><code>
gen get
</code></p>

<p>Add the third-party tag to your type annotation:</p>

<p><code>
// +gen slice:"Where,Count,GroupBy[string]" bling:"Diamonds,Bentleys"
type MyType struct {
}
</code></p>

<p>And gen it again:</p>

<p><code>
gen
</code></p>

<p>You should have a new file <code>mytype_bling.go</code> (assuming the author followed naming conventions). Refer to the third-party&rsquo;s documentation to understand what their tags do, of course.</p>

<h3>Implementing TypeWriters</h3>

<p>You can create your own type writer by implementing the <a href="godoc">TypeWriter interface</a>.</p>

<p>As mentioned above, typewriters follow the pattern of codecs in the image package of Go&rsquo;s standard library. They are registered via an <code>init()</code> method.</p>

<p>The best thing to do is have a look at an existing implementation, <a href="https://github.com/clipperhouse/typewriters/container">List</a> is straightforward.</p>

<p>The <a href="https://github.com/clipperhouse/typewriter">typewriter package</a> handles tag parsing and type evaluation, and passes this information to your typewriter. It offers some conveniences for text templating, as well.</p>

<p>There aren&rsquo;t many third-party packages as of this writing, so don&rsquo;t hesistate to ask me (Matt) for help. We want to make it easy, and maybe even build an ecosystem.</p>

<p>We&rsquo;d love to see a typewriter for strongly-typed json serialization, for example.</p>

<h2>FAQ</h2>

<p><strong>Codegen, really?</strong></p>

<p>Yes! It felt a bit dirty to us at the beginning, too. But it turns out that a lot of actual generics implementations look a lot like code generation &ndash; you just don&rsquo;t see it. (Compilers and JITs do it for you.)</p>

<p>Code generation removes mystery. It&rsquo;s just code, right there in your package. Read it. The history goes in your repo like everything else.</p>

<p>You get all the usual compiler checks and optimizations, of course, so gen won&rsquo;t introduce surprises in production.</p>

<p>gen is a <em>tool</em> that helps the developer produce code on their local workstation, alongside their text editor and utilities.</p>

<p><strong>Wait, is this <code>go generate</code>?</strong></p>

<p>No, <a href="https://docs.google.com/document/d/1V03LUfjSADDooDMhe-_K59EgpTEm3V8uvQRuNMAEnjg/edit">that&rsquo;s</a> different (and very cool). <code>go generate</code> will run any command and is intended to obviate <code>make</code> files and such. <code>gen</code> is specifically about codegen for types.</p>

<p>The two tools are complementary.</p>

<p><strong>Can I run gen on the server?</strong></p>

<p>Like as part of the build? Sure, but that&rsquo;s not what it&rsquo;s designed around so we don&rsquo;t recommend it.</p>

<p>It&rsquo;s a local dev tool, not a platform or (shudder) a framework. Run it locally, test it, and commit the generated code to the repo.</p>
